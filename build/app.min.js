var Audio = (function(){

    function Audio(){
        this.sound = new buzz.sound( "assets/sounds/train", {
            formats: [ "wav" ],
            volume: 0
        });
        this.duration = 3115;
        this.sound.play()
            .fadeTo(25)
            .loop();
    }

    Audio.prototype.startTunnel = function() {
        
    };

    Audio.prototype.stopTunnel = function() {
        
    };

    Audio.prototype.update = function() {
        if(this.sound.getTime() > 3.00) {
            this.sound.setTime(0);
        }
    };

    return Audio;

})();
var OcclusionScene = (function(){

    function OcclusionScene(width, height, renderer){
        this.width = width;
        this.height= height;
        this.sunColor = 0x795a38;
        
        this.scene = new THREE.Scene();
         
        this.camera = new THREE.PerspectiveCamera(40, width / height, 0.1, 100000);
        this.camera.position.set(0, 100, 1000);
        this.camera.lookAt(new THREE.Vector3(0, 100, 0));

        this.mountain = new Mountain(true);
        this.scene.add(this.mountain);
        this.mountain.position.set(0, -2000, -20000);

        this.sunMesh = new THREE.Mesh(new THREE.CircleGeometry(800, 64), new THREE.MeshBasicMaterial({color: this.sunColor}));
        this.scene.add(this.sunMesh);
        this.sunMesh.position.set(0, 1600, -22000);

        this.tunnel = new Tunnel(true);
        this.scene.add(this.tunnel);

        var renderTargetParameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBufer: false };
        this.renderTarget = new THREE.WebGLRenderTarget(this.width, this.height, renderTargetParameters);
                
        this.addPostprocessing(renderer);
    }

    OcclusionScene.prototype.addPostprocessing = function(renderer) {
        this.composer = new THREE.EffectComposer(renderer, this.renderTarget);
        this.composer.addPass(new THREE.RenderPass(this.scene, this.camera));

        var hblur = new THREE.ShaderPass(THREE.HorizontalBlurShader);
        var vblur = new THREE.ShaderPass(THREE.VerticalBlurShader);
        hblur.uniforms.h.value = 8 / this.width;
        vblur.uniforms.v.value = 8 / this.height;
        
        this.composer.addPass(hblur);
        this.composer.addPass(vblur);
        this.composer.addPass(hblur);
        this.composer.addPass(vblur);
        
        
        var grPass = new THREE.ShaderPass(GodraysShader);
        this.composer.addPass(grPass);

        // vblur.renderToScreen = true;
    };

    OcclusionScene.prototype.resize = function(width, height) {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.width = width;
        this.height = height;
    };

    OcclusionScene.prototype.render = function(renderer) {
        this.mountain.update();
        this.tunnel.update();
        renderer.setClearColor(0x000000)
        // renderer.render(this.scene, this.camera);
        this.composer.render();

    };

    return OcclusionScene;

})();
var Painter = (function(){

    function Painter(width, height){
        this.width = width;
        this.height = height;

        this.canvas = document.createElement('canvas');
        this.ctx = this.canvas.getContext('2d');
        this.ctx.lineJoin = this.ctx.lineCap = 'round';

        this.resize(width, height);

        this.brushImage = new Image();
        this.brushImage.src = 'assets/textures/brush5.png';

        this.titleImagePolar = new Image();
        this.titleImagePolar.src = 'assets/textures/polar.png';
        this.titleWidth = 524;
        this.titleHeight = 54;

        this.titleImageSolar = new Image();
        this.titleImageSolar.src = 'assets/textures/solar.png';

        this.isDrawing = false;
        this.lastPoint = null;

        this.drawSolar = false;

        this.lastTime = 0;
        this.clearInterval = 0.25;

        this.ctx.fillRect(0, 0, width, height);
    }

    Painter.prototype.mouseDown = function(e) {
        if(!this.introOver) return;
        this.isDrawing = true;
        this.lastPoint = { x: e.clientX, y: e.clientY };
    };

    Painter.prototype.mouseUp = function(e) {
        this.isDrawing = false;
    };

    Painter.prototype.mouseMove = function(e) {
        if(!this.isDrawing || !this.introOver) return;

        this.drawCurrentPointBrush(e.clientX, e.clientY);
    };

    Painter.prototype.drawCurrentPointBrush = function(x, y) {
        var currentPoint = { x: x, y: y };
        var dist = this.distanceBetween(this.lastPoint, currentPoint);
        var angle = this.angleBetween(this.lastPoint, currentPoint);

        for(var i = 0; i < dist; i++) {
            x = this.lastPoint.x + (Math.sin(angle) * i) - 25;
            y = this.lastPoint.y + (Math.cos(angle) * i) - 25;
            this.ctx.drawImage(this.brushImage, x, y);
        }
        this.ctx.drawImage(this.drawSolar ? this.titleImageSolar : this.titleImagePolar, this.width * 0.5 - this.titleWidth * 0.5, this.height * 0.5 - this.titleHeight * 0.5);
        this.lastPoint = currentPoint;
    };

    Painter.prototype.distanceBetween = function(point1, point2) {
        return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
    };

    Painter.prototype.angleBetween = function(point1, point2) {
        return Math.atan2(point2.x - point1.x, point2.y - point1.y);
    };

    Painter.prototype.resize = function(width, height) {
        this.width = width;
        this.height = height;
        this.canvas.width = width;
        this.canvas.height = height;
    };

    Painter.prototype.reset = function() {
        this.ctx.fillStyle = 'rgba(0, 0, 0, 1.0)';
        this.ctx.fillRect(0, 0, this.width, this.height);
    };

    Painter.prototype.startIntro = function() {
        var point = {x: this.width * 0.5 - 350, y: this.height * 0.5 + 50};
        this.lastPoint = { x: point.x, y: point.y };
        var tl = new TimelineMax({onUpdate: function(){
            this.drawCurrentPointBrush(point.x, point.y);
        }.bind(this), onComplete: function(){
            this.introOver = true;
        }.bind(this)});
        tl.to(point, 0.4, {x: point.x + 100, y: point.y - 150, ease: Quart.easeIn});
        tl.to(point, 0.15, {x: point.x + 140, y: point.y, ease: Linear.easeNone});
        tl.to(point, 0.15, {x: point.x + 210, y: point.y - 160, ease: Linear.easeNone});
        tl.to(point, 0.15, {x: point.x + 250, y: point.y, ease: Linear.easeNone});
        tl.to(point, 0.15, {x: point.x + 320, y: point.y - 140, ease: Linear.easeNone});
        tl.to(point, 0.15, {x: point.x + 360, y: point.y, ease: Linear.easeNone});
        tl.to(point, 0.15, {x: point.x + 400, y: point.y - 150, ease: Linear.easeNone});
        tl.to(point, 0.15, {x: point.x + 410, y: point.y, ease: Linear.easeNone});
        tl.to(point, 0.15, {x: point.x + 490, y: point.y - 160, ease: Linear.easeNone});
        tl.to(point, 0.15, {x: point.x + 550, y: point.y, ease: Linear.easeNone});
        tl.to(point, 0.4, {x: point.x + 600, y: point.y - 150, ease: Quart.easeOut});
    };

    Painter.prototype.render = function(time) {
        if((time - this.lastTime) > this.clearInterval) {
            this.lastTime = time;
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            this.ctx.fillRect(0, 0, this.width, this.height);
            this.ctx.drawImage(this.drawSolar ? this.titleImageSolar : this.titleImagePolar, this.width * 0.5 - this.titleWidth * 0.5, this.height * 0.5 - this.titleHeight * 0.5);
        }
    };

    return Painter;

})();
var Webgl = (function(){

    function Webgl(width, height, painterCanvas, container){
        this.width = width;
        this.height= height;
        this.backgroundColor = 0x75b6d8;
        this.ambientColor = 0x2d6785;
        this.fogColor = 0x51B5E8;
        this.enablePainter = true;
        this.painterCanvasTexture = new THREE.Texture(painterCanvas);

        this.debug = false;
        this.switchColorScheme = false;

        this.clock = new THREE.Clock();

        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(this.fogColor, 0.0001);
        
        this.frontScene = new THREE.Scene();
        
        
        this.camera = new THREE.PerspectiveCamera(40, width / height, 0.1, 100000);
        this.camera.position.set(0, 100, 1000);
        this.camera.lookAt(new THREE.Vector3(0, 100, 0));

        this.renderer = new THREE.WebGLRenderer({autoClear: false});
        this.renderer.autoClear = false;
        this.renderer.setSize(width, height);
        this.renderer.setClearColor(this.backgroundColor);
        container.appendChild(this.renderer.domElement);

        this.light = new THREE.PointLight(0xFFFFFF, 1);
        this.scene.add(this.light);
        this.light.position.set(0, 1200, -7000);

        this.ambientLight = new THREE.AmbientLight(this.ambientColor);
        this.scene.add(this.ambientLight);

        this.terrain = new Terrain(width, height);
        this.scene.add(this.terrain);

        this.fallingSnow = new FallingSnow();
        this.scene.add(this.fallingSnow);

        this.tunnel = new Tunnel();
        this.frontScene.add(this.tunnel);


        this.mountain = new Mountain();
        this.scene.add(this.mountain);
        this.mountain.position.set(0, -2000, -20000);

        this.backgroundMesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(400000, 10000), new THREE.MeshBasicMaterial({color: this.mountain.colors.top, fog: false}));
        this.scene.add(this.backgroundMesh);
        this.backgroundMesh.position.set(0, -7000, -20010);

        this.occlusion = new OcclusionScene(width, height, this.renderer);

        if(this.debug) {
            this.controls = new THREE.TrackballControls(this.camera, this.renderer.domElement);
        }
        else {
            this.addPostprocessing();
        }

        if(this.debug) {
            gui.addColor(this, 'backgroundColor').listen().onChange(function(){
                this.renderer.setClearColor(this.backgroundColor);
            }.bind(this)).name('Clear Color');
            gui.addColor(this, 'fogColor').onChange(function(){
                this.scene.fog.color.setHex(this.fogColor);
            }.bind(this)).listen().name('Fog Color');
            gui.addColor(this, 'ambientColor').listen().onChange(function(){
                this.ambientLight.color.setHex(this.ambientColor);
            }.bind(this)).name('Ambient Color');
            gui.addColor(this.occlusion, 'sunColor').onChange(function(){
                this.occlusion.sunMesh.material.color.setHex(this.occlusion.sunColor);
            }.bind(this)).listen().name('Sun Color');
            gui.add(this.fallingSnow, 'visible').name('Show Snow');

            gui.add(this, 'switchColorScheme').onChange(this.toggleColorScheme.bind(this)).name('Toggle Hot');
        }
    }

    Webgl.prototype.tunnelTransition = function() {
        if(!this.tunnelTransitionRunning) {
            this.tunnelTransitionRunning = true;
            this.switchColorScheme = !this.switchColorScheme;
            this.tunnel.start(function(){
                audio.startTunnel();
                window.painter.drawSolar = this.switchColorScheme;
                window.painter.reset();
                TweenMax.to(this.lightenPass.uniforms.brightness, 0.3, {value: 0});
                TweenMax.to(this.lightenPass.uniforms.contrast, 0.3, {value: 0});
            }.bind(this), function(){
                audio.stopTunnel();
                if(this.switchColorScheme) {
                    TweenMax.to(this.lightenPass.uniforms.brightness, 0.3, {value: 0.05});
                    TweenMax.to(this.lightenPass.uniforms.contrast, 0.3, {value: 0.1});
                }
                else {
                    TweenMax.to(this.lightenPass.uniforms.brightness, 0.3, {value: 0.1});
                    TweenMax.to(this.lightenPass.uniforms.contrast, 0.3, {value: -0.2});
                }
                this.tunnelTransitionRunning = false;
            }.bind(this));
            this.occlusion.tunnel.start();
            TweenMax.delayedCall(1, function(){
                this.toggleColorScheme();
            }.bind(this));
        }
    };

    Webgl.prototype.toggleColorScheme = function() {
        if(this.switchColorScheme) {
            this.backgroundColor = 0x117cb3;
            this.fogColor = 0x9d8469;
            this.ambientColor = 0xb36E0F;
            this.occlusion.sunColor = 0xFF5A00;
            this.mountain.colors.top = 0x988264;
            this.mountain.colors.bottom = 0x7d7d3d;
            this.fallingSnow.visible = false;
        }
        else {
            this.backgroundColor = 0x75b6d8;
            this.fogColor = 0x51B5E8;
            this.ambientColor = 0x2d6785;
            this.occlusion.sunColor = 0x795a38;
            this.mountain.colors.top = 0x5aa9d2;
            this.mountain.colors.bottom = 0x415d6c;
            this.fallingSnow.visible = true;
        }

        this.renderer.setClearColor(this.backgroundColor);
        this.scene.fog.color.setHex(this.fogColor);
        this.ambientLight.color.setHex(this.ambientColor);
        this.occlusion.sunMesh.material.color.setHex(this.occlusion.sunColor);
        this.mountain.uniforms.colorTop.value.setHex(this.mountain.colors.top);
        this.mountain.uniforms.colorBottom.value.setHex(this.mountain.colors.bottom);
        this.backgroundMesh.material.color.setHex(this.mountain.colors.top);
    };

    Webgl.prototype.addPostprocessing = function() {
        this.composer = new THREE.EffectComposer(this.renderer);
        this.renderPass = new THREE.RenderPass(this.scene, this.camera)
        this.composer.addPass(this.renderPass);

        // Render tunnel in front of everything
        this.renderPassFront = new THREE.RenderPass(this.frontScene, this.camera)
        this.renderPassFront.clear = false;
        this.renderPassFront.clearDepth = true;
        this.composer.addPass(this.renderPassFront);

        // Vignette
        this.composer.addPass(new THREE.ShaderPass(THREE.VignetteShader));

        // Light effects from occlusion scene
        this.glowPass = new THREE.ShaderPass(AdditiveTextureShader);
        this.glowPass.uniforms.tDiffuse2.value = this.occlusion.renderTarget;
        this.composer.addPass(this.glowPass);

        // Save untouched rendering for later use
        var renderTargetParams = { 
            minFilter: THREE.LinearFilter, 
            magFilter: THREE.LinearFilter, 
            format: THREE.RGBFormat, 
            stencilBuffer: false 
        };
        this.savedRenderTarget = new THREE.WebGLRenderTarget(this.width, this.height, renderTargetParams);
        this.savePass = new THREE.SavePass(this.savedRenderTarget);
        this.composer.addPass(this.savePass);

        // Blur
        this.vBlurCold = new THREE.ShaderPass(THREE.VerticalBlurShader);
        this.hBlurCold = new THREE.ShaderPass(THREE.HorizontalBlurShader);
        this.bluriness = 2;
        this.vBlurCold.uniforms.v.value = this.bluriness / this.height;
        this.hBlurCold.uniforms.h.value = this.bluriness / this.width;
        this.composer.addPass(this.vBlurCold);
        this.composer.addPass(this.hBlurCold);

        // Lighten
        this.lightenPass = new THREE.ShaderPass(THREE.BrightnessContrastShader);
        this.composer.addPass(this.lightenPass);
        this.lightenPass.uniforms.brightness.value = 0.1;
        this.lightenPass.uniforms.contrast.value = -0.2;

        // Copy needed here for lighten to work...
        this.copyPass = new THREE.ShaderPass(THREE.CopyShader);
        this.composer.addPass(this.copyPass);
        
        // Apply masked saved rendering on top of blurry lightened
        this.maskPass = new THREE.ShaderPass(TextureMaskShader);
        this.composer.addPass(this.maskPass);
        this.maskPass.uniforms.tDiffuse2.value = this.savedRenderTarget;
        this.maskPass.uniforms.tMask.value = this.painterCanvasTexture;
        this.maskPass.renderToScreen = true;
    };

    Webgl.prototype.resize = function(width, height) {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
        this.composer.setSize(width, height);
        this.occlusion.resize(width, height);
        // this.savedRenderTarget.setSize(width, height);
        this.vBlurCold.uniforms.v.value = this.bluriness / this.height;
        this.hBlurCold.uniforms.h.value = this.bluriness / this.width;
        this.savePass.clear = true;
    };

    Webgl.prototype.render = function() {
        var t = this.clock.getElapsedTime();

        this.painterCanvasTexture.needsUpdate = true;
        
        this.terrain.update(t, this.renderer);
        this.fallingSnow.update();
        this.mountain.update();
        this.tunnel.update();

        this.occlusion.render(this.renderer);

        if(this.debug) {
            this.renderer.render(this.scene, this.camera);
            this.controls.update();
        }
        else {
            this.renderer.setClearColor(this.backgroundColor);
            this.composer.render();
        }
    };

    return Webgl;

})();
var webgl, gui, painter, stats, audio;

document.addEventListener('DOMContentLoaded', init);

function init(){

    // gui = new dat.GUI({width: 400});
    // gui.close();
    
    painter = new Painter(window.innerWidth, window.innerHeight);

    webgl = new Webgl(window.innerWidth, window.innerHeight, painter.canvas, document.querySelector('.three'));
    // document.querySelector('.painter-debug').appendChild(painter.canvas);

    audio = new Audio();

    // stats = new Stats();
    // stats.domElement.style.position = 'absolute';
    // stats.domElement.style.left = '0px';
    // stats.domElement.style.top = '0px';
    // document.body.appendChild( stats.domElement );

    window.onresize = resizeHandler;

    window.addEventListener('mouseup', onMouseUp);
    window.addEventListener('touchend', onMouseUp);
    window.addEventListener('keyup', onKeyUp);
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('touchstart', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('touchmove', onTouchMove);

    var button = document.querySelector('.invert-button');

    button.addEventListener('click', webgl.tunnelTransition.bind(webgl));

    animate();

    painter.startIntro();
}

function onKeyUp(e) {
    if(e.keyCode === 32) {
        webgl.tunnelTransition();
    }
}

function onMouseUp(e) {
    if(webgl.enablePainter)
        painter.mouseUp(e);
}

function onMouseDown(e) {
    if(webgl.enablePainter)
        painter.mouseDown(e);
}

function onMouseMove(e) {
    if(webgl.enablePainter)
        painter.mouseMove(e);
}

function onTouchMove(e) {
    if(webgl.enablePainter)
        painter.mouseMove(e.targetTouches[0]);
}

function resizeHandler() {
    webgl.resize(window.innerWidth, window.innerHeight);
    painter.resize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    audio.update();
    // stats.begin();
    if(webgl.enablePainter)
        painter.render(webgl.clock.elapsedTime);    
    webgl.render();
    // stats.end();
}
var Asset = (function(){

    function Asset(url, index, type) {
        this.url = url;
        this.index = index;
        this.type = type;
        this.startedLoading = false;
        this.loaded = false;
        this.buffer = 0;
        this.presetList = new Array();
    }

    Asset.prototype.load = function(preset) {
        if (this.loaded) {
            // Already loaded
            preset.assetFinishedLoading(this);
            return;
        }

        // Keep track of this preset as a dependency
        var n = this.presetList.length;
        this.presetList[n] = preset;
        
        if (this.startedLoading) {
            return;
        }

        this.startedLoading = true;
            
        // Load asynchronously
        var request = new XMLHttpRequest();
        request.open("GET", this.url, true);
        request.responseType = "arraybuffer";
        this.request = request;
        
        var asset = this;

        request.onload = function() {
            context.decodeAudioData(
                request.response,
                function(buffer) {
                    asset.buffer = buffer;
                    asset.loaded = true;
                    
                    // Tell all the presets that depend on us that we're ready
                    for (i = 0; i < asset.presetList.length; i++) {
                        var preset = asset.presetList[i];
                        preset.assetFinishedLoading(asset);
                    }
                },
                
                function(buffer) {
                    // alert("ERROR!!!!! " + asset.url);
                }
            );
        }

        request.send();
    }
    
    return Asset;
})();

var Preset = (function(){

    function Preset(presetIndex, title, sampleIndex, impulseResponseIndex, mainGain, sendGain) {
        this.mainGain = mainGain;
        this.sendGain = sendGain;

        this.title = title;
        this.presetIndex = presetIndex;
        this.sampleIndex = sampleIndex;
        this.impulseResponseIndex = impulseResponseIndex + responseOffset; // passed in index starts at 0 for responses
        this.sampleBuffer = 0;
        this.impulseResponseBuffer = 0;
    }

    Preset.prototype.assetFinishedLoading = function(asset) {
        switch (asset.type) {
            case 0: this.sampleBuffer = asset.buffer; break;
            case 1: this.impulseResponseBuffer = asset.buffer; break;
        }
        
        if (this.isFullyLoaded()) {
            // Autoplay first preset
            if (this.presetIndex == 0) {
                this.play();
            }
        }
    }

    Preset.prototype.isFullyLoaded = function() {
        return this.sampleBuffer && this.impulseResponseBuffer;
    }

    Preset.prototype.load = function() {
        sampleAsset = assetList[this.sampleIndex];
        impulseResponseAsset = assetList[this.impulseResponseIndex];
        
        sampleAsset.load(this);
        impulseResponseAsset.load(this);    
    }

    Preset.prototype.play = function() {
        source.buffer = this.sampleBuffer;
        convolver.buffer = this.impulseResponseBuffer;

        gainNode1.gain.value = this.mainGain;
        gainNode2.gain.value = this.sendGain;

        if (!isStarted) {
            isStarted = true;
            source.start(0);
        }
    }

    return Preset;

})();
var FallingSnow = (function(){

    function FallingSnow(){
        THREE.Object3D.call(this);

        this.zone = new THREE.Vector3(4000, 1000, 2000);
        this.nbParticles = 20000;

        var geometry = new THREE.BufferGeometry();
        var positions = new Float32Array(this.nbParticles * 3);
        
        for(var i = 0, j = 0; i < this.nbParticles; i++, j += 3) {
            positions[j + 0] = Math.random() * this.zone.x - this.zone.x * 0.5;
            positions[j + 1] = Math.random() * this.zone.y - this.zone.y * 0.5;
            positions[j + 2] = Math.random() * this.zone.z - this.zone.z * 0.5;
        }

        geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));

        var snowFlakeTexture = THREE.ImageUtils.loadTexture('assets/textures/snowflake.png');
        var uniforms = THREE.UniformsUtils.clone(SnowParticleShader.uniforms);
        uniforms.texture.value = snowFlakeTexture;
        uniforms.color.value.setHex(0xFFFFFF);
        uniforms.size.value = 2.0;

        var material = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: SnowParticleShader.vertexShader,
            fragmentShader: SnowParticleShader.fragmentShader,
            blending: THREE.AdditiveBlending,
            transparent: true
        });
        
        this.pointCloud = new THREE.PointCloud(geometry, material);
        this.add(this.pointCloud);
    }

    FallingSnow.prototype = new THREE.Object3D;
    FallingSnow.prototype.constructor = FallingSnow;

    FallingSnow.prototype.update = function() {
        var positions = this.pointCloud.geometry.attributes.position.array;
        for(var i = 0, j = 0; i < this.nbParticles; i++, j += 3) {
            positions[j + 1] -= 1;
            positions[j + 0] -= 2.5;
            if(positions[j + 1] < (-this.zone.y * 0.5)) {
                positions[j + 1] = this.zone.y * 0.5;
                positions[j + 0] = -positions[j + 0];
            }
        }
        this.pointCloud.geometry.attributes.position.needsUpdate = true;
    };

    return FallingSnow;
})();
var Mountain = (function(){

    function Mountain(isOccluding){
        THREE.Object3D.call(this);
        
        var terPoints = [183.8913420215249,183.12427003703482,187.86017283612907,187.9684585523993,184.2202560658527,186.5590813510202,187.78918639737535,192.2619798224098,196.27027776154912,199.8499035306104,198.88545726249896,204.04843085055202,202.8662468264407,202.54961729264397,201.96003472348946,208.48348253031864,210.47282528604316,211.39525643920547,207.49233439047617,208.65817422239624,213.39115065000982,216.51593723596557,223.65007518613254,228.08431599059395,227.18199198550423,225.9787548919379,231.47162019533036,229.43601244222958,226.42483616828602,229.3762847239669,230.70681761842795,227.66746243546095,230.29288402735054,226.30559202101355,224.0205430284197,225.3662961024547,221.69765334214145,222.847426291343,218.67452405038014,218.79650232229068,224.8284415158905,228.0816929072315,229.35819932093904,229.01117347746114,232.86455694952784,234.97812532355985,233.96911566216914,234.9938843277432,235.08936962945359,232.26251995311,232.1444522159032,230.85872683026415,234.17287685437256,229.56496721407305,228.75000901785893,224.95350431081806,223.82940932577648,224.32235570236992,221.22662243706293,226.01497098243607,223.93647398537684,224.20150561500603,226.0302620523236,226.66208702242417,223.29572404768177,226.8899805740177,230.23435477853215,234.92759792568563,237.32300739906606,236.2520635087821,236.65238372380412,238.16986513473816,240.73318449396595,242.94101569414386,245.30940448907958,248.74928303375088,245.986031698692,243.29918872950861,243.59781265951375,239.82589015304742,240.25993448156774,240.80823469963826,243.10977703165662,245.87441617642784,252.16318633474194,253.98261019855175,261.0352331673411,261.68663485336333,262.33601238612357,259.35197808312284,262.7440175615355,262.95308637893913,268.18060379026696,270.9342627421014,267.52540312798993,262.688258529194,261.8625547929831,264.99818787931514,271.1208424819301,273.03775651514184,281.3332336248237,283.13851721162246,281.6372007931925,286.75815585838996,286.71061782290025,285.83574333998075,291.79503578342167,292.7307271859847,294.42066740812214,297.44200257995925,293.79457548880373,299.25207758660713,300.05949963018884,301.02739954188894,303.76836385478765,301.8077755969088,299.9305103922269,297.000983415454,292.89575037650826,287.57589367099297,289.1809926753971,292.0443467654319,289.77651325463313,291.4264448441765,299.8813801480248,300.0639696595828,302.1308713773931,299.92383915306067,300.83178977907517,299.3516432415897,303.8737866501964,304.952667546633,302.63726294237506,297.06847947601636,295.77829716857553,297.6874202980122,296.7722178411707,294.01486487040506,293.6837956217582,286.5289871166719,285.07051804035825,282.1594461892012,281.8984674900575,284.1095289657805,283.2951405652187,280.89222221132155,285.333112071169,285.82538957389346,281.32784346879106,281.0816063235376,281.7567173212568,284.67289571694045,292.18855287477226,295.3023429020924,293.90283142126873,290.8675886812255,285.0082545182727,282.6924996569873,284.2555300448393,287.1957593778427,291.9591071481795,289.9326058492917,293.7948878858235,287.4294506127379,286.6303588868027,287.3404009173057,284.31670857404663,280.75536182623625,280.63541332566473,282.08420942755583,288.56878702754733,285.2204805838385,286.9821993459243,285.670625861723,286.43962933271376,283.0527561175027,285.6563707681586,283.4233152026622,282.91020791953474,279.10655563801384,272.37275409516525,274.49474173216356,274.17647285403785,270.41854025477653,267.72748916495607,263.62222100995183,263.133676718281,260.74433737349676,259.6267727399151,261.9964451341145,261.15981785570204,262.99920791129284,258.90709699485467,260.9614465819934,260.3572442203536,262.8303226744513,270.0256333416011,275.24140260441976,279.4782233920869,276.38276800541485,278.66017440646004,276.4208114993558,273.93154199054027,274.4170378681188,275.2174870101614,275.22813959427293,276.93003521866683,277.77770747857414,283.0398807839935,283.0780481898836,276.2604508141585,277.95778808414104,276.43354540600546,277.01768292251995,282.3509302424151,283.64594049331856,285.65037174787597,286.6614935977926,286.68096725684984,289.5011296072403,290.26622366727935,291.1759303052087,289.76438913947555,288.0646554772118,291.9444858941963,289.1034033762649,284.25889395081595,278.3698866145222,278.6475852026187,279.768874302087,281.8869772791605,278.86001853956986,275.4899309881743,273.6363228504798,273.03340292968414,272.78425913166296,277.6793550508779,278.2297393000349,274.3701712960595,275.68146809734515,273.6309060905914,268.1422984360878,269.36664549542013,268.07827476633423,266.7441681182397,266.3964010311217,270.61253354297884,268.83049983378567,272.27980107322117,278.6535121301005,278.1827052689249,277.81766954315736,281.4430578795174,279.9281758322153,276.66351708735687,275.61881789718893,279.7924263407243,277.11915309921477,279.72657008823234,278.9375669727894,277.2033594577305,273.47669081048355,276.0369699586559];

        var offset = 1;
        var sub = 100;
        var stepLength = 4;
        var shape = new THREE.Shape();
        shape.moveTo(0, terPoints[0] - sub);
        for (var i = 1, l = terPoints.length; i < l; i++) {
			shape.lineTo(offset, terPoints[i] - sub);
			offset += stepLength;
        }
        for (var i = l - 1; i > 0; i--) {
			shape.lineTo(offset, terPoints[i] - sub);
			offset += stepLength;
        }
        shape.lineTo(offset, 0);
        shape.lineTo(0, 0);
        shape.lineTo(0, terPoints[0] - sub);

        this.meshWidth = terPoints.length * stepLength * 2;

		var geometry = new THREE.ShapeGeometry(shape);
		var material;
		if(isOccluding) {
			material = new THREE.MeshBasicMaterial({
				fog: false,
				color: 0x000000
			});
		}
		else {
			this.colors = {
				top: 0x5aa9d2,
				bottom: 0x415d6c
			}

			this.uniforms = THREE.UniformsUtils.clone(MountainGradientShader.uniforms);
			this.uniforms.colorTop.value.setHex(this.colors.top);
			this.uniforms.colorBottom.value.setHex(this.colors.bottom);

			// gui.add(this.uniforms.maxheight, 'value').min(0).max(1000).name('Gradient Mountain Height');
			// gui.addColor(this.colors, 'top').listen().onChange(function(){
			// 	this.uniforms.colorTop.value.setHex(this.colors.top);
			// }.bind(this)).name('Gradient Mountain Top');
			// gui.addColor(this.colors, 'bottom').listen().onChange(function(){
			// 	this.uniforms.colorBottom.value.setHex(this.colors.bottom);
			// }.bind(this)).name('Gradient Mountain Bottom');

			material = new THREE.ShaderMaterial({
				vertexShader: MountainGradientShader.vertexShader,
				fragmentShader: MountainGradientShader.fragmentShader,
				uniforms: this.uniforms,
				fog: false
			});
		}

		

		this.mesh1 = new THREE.Mesh(geometry, material);
		this.scale.multiplyScalar(20);
		this.mesh1.position.x -= this.meshWidth * 0.5;
		
		this.mesh2 = this.mesh1.clone();
		this.mesh2.position.x = this.mesh1.position.x + this.meshWidth - 10;

		this.add(this.mesh1);
		this.add(this.mesh2);
    }

    Mountain.prototype = new THREE.Object3D;
    Mountain.prototype.constructor = Mountain;

    Mountain.prototype.update = function() {
    	this.mesh1.position.x -= 10;
    	this.mesh2.position.x -= 10;
    	if(this.mesh1.position.x < -this.meshWidth * 1.5) {
    		this.mesh1.position.x = this.mesh2.position.x + this.meshWidth - 10;
    	}
    	if(this.mesh2.position.x < -this.meshWidth * 1.5) {
    		this.mesh2.position.x = this.mesh1.position.x + this.meshWidth - 10;
    	}
    };

    return Mountain;
})();


var Terrain = (function(){

    function Terrain(width, height){
        THREE.Object3D.call(this);

        this.sceneRenderTarget = new THREE.Scene();
        this.cameraOrtho = new THREE.OrthographicCamera(width / - 2, width / 2, height / 2, height / - 2, -10000, 10000);
        this.cameraOrtho.position.z = 100;
        this.sceneRenderTarget.add(this.cameraOrtho);

        var normalShader = THREE.NormalMapShader;
        var rx = 256, ry = 256;
        var pars = { 
            minFilter: THREE.LinearMipmapLinearFilter, 
            magFilter: THREE.LinearFilter, 
            format: THREE.RGBFormat 
        };

        this.heightMap = new THREE.WebGLRenderTarget(rx, ry, pars);
        this.normalMap = new THREE.WebGLRenderTarget(rx, ry, pars);

        this.uniformsNormal = THREE.UniformsUtils.clone(THREE.NormalMapShader.uniforms);
        this.uniformsNormal.height.value = 0.05;
        this.uniformsNormal.resolution.value.set(rx, ry);
        this.uniformsNormal.heightMap.value = this.heightMap;
        var materialNormal = new THREE.ShaderMaterial({
            uniforms: this.uniformsNormal,
            vertexShader: THREE.NormalMapShader.vertexShader,
            fragmentShader: THREE.NormalMapShader.fragmentShader
        });

        this.uniformsNoise = THREE.UniformsUtils.clone(SimplexNoiseShader.uniforms);
        this.uniformsNoise.scale.value.set(1, 1);
        var materialNoise = new THREE.ShaderMaterial({
            uniforms: this.uniformsNoise,
            vertexShader: SimplexNoiseShader.vertexShader,
            fragmentShader: SimplexNoiseShader.fragmentShader
        });

        this.planeNoise = new THREE.Mesh(new THREE.PlaneBufferGeometry(width, height), materialNoise);
        this.sceneRenderTarget.add(this.planeNoise);
        this.planeNoise.position.z = -500;

        this.planeNormal = new THREE.Mesh(new THREE.PlaneBufferGeometry(width, height), materialNormal);
        this.sceneRenderTarget.add(this.planeNormal);
        this.planeNormal.position.z = -500;

        var shaderTerrain = THREE.ShaderLib['normalmap'];

        this.uniformsTerrain = THREE.UniformsUtils.clone(shaderTerrain.uniforms);
        this.uniformsTerrain[ "enableSpecular" ].value = true;
        this.uniformsTerrain[ "enableDisplacement" ].value = true;
        this.uniformsTerrain[ "tNormal" ].value = this.normalMap;
        this.uniformsTerrain[ "tSpecular" ].value = this.heightMap;
        this.uniformsTerrain[ "tDisplacement" ].value = this.heightMap;
        this.uniformsTerrain[ "uDisplacementScale" ].value = 1000.0;
        this.uniformsTerrain[ "uNormalScale" ].value.set(0.0, 0.5);
        this.uniformsTerrain[ "diffuse" ].value.setHex( 0xFFFFFF );
        this.uniformsTerrain[ "shininess" ].value = 50.0;

        this.terrainMaterial = new THREE.ShaderMaterial({
            uniforms: this.uniformsTerrain,
            vertexShader: shaderTerrain.vertexShader,
            fragmentShader: shaderTerrain.fragmentShader,
            lights: true,
            fog: true
        });
        this.terrainGeometry = new THREE.PlaneBufferGeometry(16000, 16000, 300, 300)
        this.terrainGeometry.computeTangents();
        this.debugMesh = new THREE.Mesh(this.terrainGeometry, this.terrainMaterial);
        this.add(this.debugMesh);
        this.debugMesh.rotation.x = -Math.PI * 0.5;
        this.debugMesh.position.y = -1200;
        this.debugMesh.position.z = -7000;
    }

    Terrain.prototype = new THREE.Object3D;
    Terrain.prototype.constructor = Terrain;

    Terrain.prototype.update = function(t, renderer) {
        this.uniformsNoise.offset.value.x += 0.01;
        this.planeNormal.visible = false;
        this.planeNoise.visible = true;
        renderer.render(this.sceneRenderTarget, this.cameraOrtho, this.heightMap, true);
        this.planeNormal.visible = true;
        this.planeNoise.visible = false;
        renderer.render(this.sceneRenderTarget, this.cameraOrtho, this.normalMap, true);
    };

    return Terrain;
})();


var Tunnel = (function(){

    function Tunnel(isOccluding){
        THREE.Object3D.call(this);

        this.tunnelLength = 30000;
        var geometry = new THREE.PlaneBufferGeometry(this.tunnelLength, 1000);
        var material;
        if(isOccluding) {
            material = new THREE.MeshBasicMaterial({color: 0x000000});
        }
        else {
            material = new THREE.MeshLambertMaterial({color: 0x232323, ambient: 0x000000});
        }

        var windowGeometry = new THREE.PlaneBufferGeometry(100, 30);
        var windowMaterial = new THREE.MeshBasicMaterial({color: isOccluding ? 0xFFCD72 : 0xFFCD72});


        this.wallMesh = new THREE.Mesh(geometry, material);
        this.add(this.wallMesh);


        // this.wallMesh.position.x = 5000;
        this.wallMesh.position.z = -3;

        this.windows = [];
        this.windowStep = 2000;
        this.nbWindows =  ~~(this.tunnelLength / this.windowStep) - 1;

        if(isOccluding) {
            var exitGeometry = new THREE.PlaneBufferGeometry(1000, 1000);
            var exitMaterial = new THREE.MeshBasicMaterial({color: 0x372716});
            var exitMesh = new THREE.Mesh(exitGeometry, exitMaterial);
            var entranceMesh = new THREE.Mesh(exitGeometry, exitMaterial);
            this.add(exitMesh);
            this.add(entranceMesh);
            exitMesh.position.set(this.tunnelLength * 0.5 + 250, 0, 0);
            entranceMesh.position.set(-(this.tunnelLength * 0.5 + 250), 0, 0);
        }



        var mesh;
        for (var i = 0; i < this.nbWindows; i++) {
        	mesh = new THREE.Mesh(windowGeometry, windowMaterial);
	        this.add(mesh);
	        this.windows.push(mesh);
            mesh.position.x = -(this.nbWindows * this.windowStep * 0.5) + i * this.windowStep;
	        mesh.position.y = 200;
        }

        this.position.x = this.tunnelLength * 0.5 + 3000;
        this.finished = true;
        
    }

    Tunnel.prototype = new THREE.Object3D;
    Tunnel.prototype.constructor = Tunnel;

    Tunnel.prototype.start = function(enterCallback, leaveCallback) {
        this.finished = false;
        this.enterCallback = enterCallback;
        this.leaveCallback = leaveCallback;
        this.entered = false;
        this.left = false;
    };

    Tunnel.prototype.update = function() {
        if(!this.finished) {
        	this.position.x -= 300;
            if(this.position.x <= (this.tunnelLength * 0.5) && !this.entered) {
                this.entered = true;
                if(this.enterCallback) this.enterCallback();
            }
            if(this.position.x <= (-this.tunnelLength * 0.5) && !this.left) {
                this.left = true;
                if(this.leaveCallback) this.leaveCallback();
            }
            if(this.position.x < -(this.tunnelLength * 0.5 + 3000)) {
                this.position.x = this.tunnelLength * 0.5 + 3000;
                this.finished = true;
            }
        }
    };

    return Tunnel;
})();
var AdditiveTextureShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"tDiffuse2": { type: "t", value: null }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [
		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDiffuse2;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel1 = texture2D( tDiffuse, vUv );",
			"vec4 texel2 = texture2D( tDiffuse2, vUv );",
			"gl_FragColor = texel1 + vec4(0.5, 0.75, 1.0, 1.0) * texel2 * 2.0;",
			// "gl_FragColor = vec4(texel1.xyz + texel2.xyz, 1.0);",

		"}"

	].join("\n")

};

 /*
 * @author Thibaut 'BKcore' Despoulain <http://bkcore.com>
 */
 var GodraysShader = {
    uniforms: {
            tDiffuse: {type: "t", value:0, texture:null},
            fX: {type: "f", value: 0.5},
            fY: {type: "f", value: 0.5},
            fExposure: {type: "f", value: 0.6},
            fDecay: {type: "f", value: 0.93},
            fDensity: {type: "f", value: 0.96},
            fWeight: {type: "f", value: 0.4},
            fClamp: {type: "f", value: 1.0}
    },

    vertexShader: [
            "varying vec2 vUv;",

            "void main() {",
                "vUv = uv;",
                "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
            "}"
    ].join("\n"),

    fragmentShader: [
            "varying vec2 vUv;",
            "uniform sampler2D tDiffuse;",

            "uniform float fX;",
            "uniform float fY;",
            "uniform float fExposure;",
            "uniform float fDecay;",
            "uniform float fDensity;",
            "uniform float fWeight;",
            "uniform float fClamp;",

            "const int iSamples = 20;",

            "void main() {",
                "vec2 deltaTextCoord = vec2(vUv - vec2(fX,fY));",
                "deltaTextCoord *= 1.0 /  float(iSamples) * fDensity;",
                "vec2 coord = vUv;",
                "float illuminationDecay = 1.0;",
                "vec4 FragColor = vec4(0.0);",

                "for(int i=0; i < iSamples ; i++)",
                "{",
                        "coord -= deltaTextCoord;",
                        "vec4 texel = texture2D(tDiffuse, coord);",
                        "texel *= illuminationDecay * fWeight;",

                        "FragColor += texel;",

                        "illuminationDecay *= fDecay;",
                "}",
                "FragColor *= fExposure;",
                "FragColor = clamp(FragColor, 0.0, fClamp);",
                "gl_FragColor = FragColor;",
            "}"
    ].join("\n")
};

/**
 * @author mrdoob / http://www.mrdoob.com
 *
 * Simple test shader
 */

var MountainGradientShader = {

	uniforms: {
		"maxheight": {type: "f", value: 300.0},
		"colorTop": {type: "c", value: new THREE.Color(0xFF0000)},
		"colorBottom": {type: "c", value: new THREE.Color(0x0000FF)}
	},

	vertexShader: [

		"varying float vHeight;",

		"void main() {",
			"vHeight = position.y;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float maxheight;",
		"uniform vec3 colorTop;",
		"uniform vec3 colorBottom;",

		"varying float vHeight;",

		"void main() {",
			"float ratioHeight = vHeight / maxheight;",
			"vec3 gradient = mix(colorTop, colorBottom, ratioHeight - 0.3);",
			"gl_FragColor = vec4( gradient, 1.0 );",

		"}"

	].join("\n")

};

//
// Description : Array and textureless GLSL 3D simplex noise function.
//      Author : Ian McEwan, Ashima Arts.
//  Maintainer : ijm
//     Lastmod : 20110409 (stegu)
//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
//               Distributed under the MIT License. See LICENSE file.
//

var SimplexNoiseShader = {

    uniforms: {
        time:   { type: "f", value: 1.0 },
        scale:  { type: "v2", value: new THREE.Vector2( 1.5, 1.5 ) },
        offset: { type: "v2", value: new THREE.Vector2( 0, 0 ) }
    },

    vertexShader: [
        "varying vec2 vUv;",
        "uniform vec2 scale;",
        "uniform vec2 offset;",

        "void main( void ) {",

            "vUv = uv * scale + offset;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform float time;",
        "varying vec2 vUv;",

        "vec4 permute( vec4 x ) {",

            "return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );",

        "}",

        "vec4 taylorInvSqrt( vec4 r ) {",

            "return 1.79284291400159 - 0.85373472095314 * r;",

        "}",

        "float snoise( vec3 v ) {",

            "const vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );",
            "const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );",

            // First corner

            "vec3 i  = floor( v + dot( v, C.yyy ) );",
            "vec3 x0 = v - i + dot( i, C.xxx );",

            // Other corners

            "vec3 g = step( x0.yzx, x0.xyz );",
            "vec3 l = 1.0 - g;",
            "vec3 i1 = min( g.xyz, l.zxy );",
            "vec3 i2 = max( g.xyz, l.zxy );",

            "vec3 x1 = x0 - i1 + 1.0 * C.xxx;",
            "vec3 x2 = x0 - i2 + 2.0 * C.xxx;",
            "vec3 x3 = x0 - 1. + 3.0 * C.xxx;",

            // Permutations

            "i = mod( i, 289.0 );",
            "vec4 p = permute( permute( permute(i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) ) + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) ) + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );",

            // Gradients
            // ( N*N points uniformly over a square, mapped onto an octahedron.)

            "float n_ = 1.0 / 7.0;", // N=7

            "vec3 ns = n_ * D.wyz - D.xzx;",

            "vec4 j = p - 49.0 * floor( p * ns.z *ns.z );", //  mod(p,N*N)

            "vec4 x_ = floor( j * ns.z );",
            "vec4 y_ = floor( j - 7.0 * x_ );", // mod(j,N)

            "vec4 x = x_ *ns.x + ns.yyyy;",
            "vec4 y = y_ *ns.x + ns.yyyy;",
            "vec4 h = 1.0 - abs( x ) - abs( y );",

            "vec4 b0 = vec4( x.xy, y.xy );",
            "vec4 b1 = vec4( x.zw, y.zw );",


            "vec4 s0 = floor( b0 ) * 2.0 + 1.0;",
            "vec4 s1 = floor( b1 ) * 2.0 + 1.0;",
            "vec4 sh = -step( h, vec4( 0.0 ) );",

            "vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;",
            "vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;",

            "vec3 p0 = vec3( a0.xy, h.x );",
            "vec3 p1 = vec3( a0.zw, h.y );",
            "vec3 p2 = vec3( a1.xy, h.z );",
            "vec3 p3 = vec3( a1.zw, h.w );",

            // Normalise gradients

            "vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), dot( p2, p2 ), dot( p3, p3 ) ) );",
            "p0 *= norm.x;",
            "p1 *= norm.y;",
            "p2 *= norm.z;",
            "p3 *= norm.w;",

            // Mix final noise value

            "vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );",
            "m = m * m;",
            "return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 ), dot( p3, x3 ) ) );",

        "}",

        "float surface3( vec3 coord ) {",

            "float n = 0.0;",

            "n += 0.5 * abs( snoise( coord ) );",
            "n += 0.25 * abs( snoise( coord * 2.0 ) );",
            "n += 0.25 * abs( snoise( coord * 4.0 ) );",
            // "n += 0.5 * abs( snoise( coord * 8.0 ) );",
            // "n += 0.075 * abs( snoise( coord * 16.0 ) );",

            "return n;",

        "}",

        "void main( void ) {",

            "vec3 coord = vec3( vUv, -time );",
            "float n = surface3( coord );",

            "gl_FragColor = vec4( vec3( n, n, n ), 1.0 );",

        "}"


    ].join("\n")

};



var SnowParticleShader = {

    uniforms: {
        "texture": {type: "t", value: null},
        "color": {type: "c", value: new THREE.Color(0xFFFFFF)},
        "size": {type: "f", value: 1.0}
    },

    vertexShader: [

        "uniform float size;",

        "void main() {",

            "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
            "gl_PointSize = size * ( 1000.0 / length( mvPosition.xyz ) );",
            "gl_Position = projectionMatrix * mvPosition;",

        "}"

    ].join("\n"),

    fragmentShader: [

        "uniform vec3 color;",
        "uniform sampler2D texture;",

        "void main() {",

            "gl_FragColor = vec4( color, 1.0 );",
            "gl_FragColor = gl_FragColor * texture2D( texture, gl_PointCoord );",

        "}",

    ].join("\n")

};

var TextureMaskShader = {

    uniforms: {

        "tDiffuse1": { type: "t", value: null },
        "tDiffuse2": { type: "t", value: null },
        "tMask":     { type: "t", value: null }

    },

    vertexShader: [

        "varying vec2 vUv;",

        "void main() {",

            "vUv = uv;",
            "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

        "}"

    ].join("\n"),

    fragmentShader: [
        "uniform sampler2D tDiffuse1;",
        "uniform sampler2D tDiffuse2;",
        "uniform sampler2D tMask;",

        "varying vec2 vUv;",

        "void main() {",

            "vec4 texel1 = texture2D( tDiffuse1, vUv );",
            "vec4 texel2 = texture2D( tDiffuse2, vUv );",
            "vec4 texelMask = texture2D( tMask, vUv );",
            "gl_FragColor = mix( texel1, texel2, texelMask.r);",

        "}"

    ].join("\n")

};

//# sourceMappingURL=app.min.js.map